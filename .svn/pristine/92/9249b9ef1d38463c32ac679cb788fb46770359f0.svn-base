package com.team1.workforest.board.notice.service.impl;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import com.team1.workforest.board.notice.mapper.NoticeMapper;
import com.team1.workforest.board.notice.service.NoticeService;
import com.team1.workforest.board.notice.vo.NoticeBoardVO;
import com.team1.workforest.vo.AttachedFileVO;

import lombok.extern.slf4j.Slf4j;


@Slf4j
@Service
public class NoticeServiceImpl implements NoticeService {
	
	@Autowired
	String uploadFolderDirect;
	
	@Autowired
	NoticeMapper noticeMapper;
	
	// 키워드 검색
	@Override
	public int getkeywordTotal(Map<String, Object> map) {
		return this.noticeMapper.getkeywordTotal(map);
	}

	// 리스트 조회
	@Override
	public List<NoticeBoardVO> list(Map<String, Object> map) {
		return this.noticeMapper.list(map);
	}

	
	
	// 조회수 증가
	@Override
	public int noticeView(String noticeBrdNo) {
		return this.noticeMapper.noticeView(noticeBrdNo);
	}

	//공지게시글 등록
	@Transactional("txManager")
	@Override
	public int createNotice(NoticeBoardVO noticeVO) {
		int result = 0;
		int flag = 0;
		int attachmnflNo = 0;
		File uploadPath = new File(uploadFolderDirect, getFolder());

		// ATTACHMNFL_NO 최댓값
		attachmnflNo = Integer.parseInt(this.noticeMapper.attachmnflNo());
		attachmnflNo++;

		// 연월일 폴더 생성
		if (!uploadPath.exists()) {
			uploadPath.mkdirs();
		}

		String uploadFileName = "";
		long size = 0;

		MultipartFile[] uploadFile = noticeVO.getUploadfile();
		log.info("uploadFile -> " + uploadFile.length);
		log.info("uploadFile -> " + uploadFile[0]);
		log.info("uploadFile -> " + uploadFile[0].getOriginalFilename());
		log.info("uploadFile -> " + uploadFile[0].getName());
		log.info("uploadFile -> " + uploadFile[0].getSize());
		String FileCheck = uploadFile[0].getOriginalFilename();
		// 파일 존재여부 확인
		if (!FileCheck.equals("") && !FileCheck.equals(null)) {
			// 원본 파일명이 있을 때만 파일 입력 처리
			log.info("파일이 있음");
			for (MultipartFile multipartFile : uploadFile) {
				String orginalFileName = multipartFile.getOriginalFilename();
				log.info("원본 파일명 : " + orginalFileName);
				log.info("파일 크기    : " + multipartFile.getSize());
				log.info("MIME타입  : " + multipartFile.getContentType());

				uploadFileName = multipartFile.getOriginalFilename();
				size = multipartFile.getSize(); // 파일 크기
				String mime = multipartFile.getContentType(); // mime타입
				String ext = orginalFileName.substring(orginalFileName.lastIndexOf("."));
				/*
				 * String ext = ""; int lastIndex = orginalFileName.lastIndexOf("."); if
				 * (lastIndex != -1) { ext = orginalFileName.substring(lastIndex); }
				 */

				UUID uuid = UUID.randomUUID();
				uploadFileName = uuid.toString() + "_" + ext;
				log.info("uploadFileName : " + uploadFileName);

				File saveFile = new File(uploadFolderDirect + File.separator + getFolder(), uploadFileName);

				try {
					// 파일 복사 실행
					multipartFile.transferTo(saveFile);

					AttachedFileVO attachFileVO = new AttachedFileVO();
					attachFileVO.setAtchmnflSize(size);
					attachFileVO.setAtchmnflNm(uploadFileName);
					attachFileVO.setAtchmnflOriginNm(orginalFileName);
					attachFileVO.setAtchmnflUrl("/" + getFolder().replace("\\", "/") + "/" + uploadFileName);
					log.info("attachmnflNo :" + attachmnflNo);

					attachFileVO.setAtchmnflNo(String.valueOf(attachmnflNo));

					log.info("attachFileVO : " + attachFileVO);

					// 파일 정보 데이터베이스에 저장
					result = this.noticeMapper.insertAttachedFile(attachFileVO);
					log.info("file result -> " + result);

					flag = 1;

				} catch (IllegalStateException | IOException e) {
					log.error("파일이 없음" + e.getMessage());
				}
			}
		}

		// 파일이 있을 경우에만 파일 정보를 설정한 후 suggestMapper.createSuggest 호출
		if (flag == 1) {
			log.info("File noticeVO -> " + noticeVO);
			result = this.noticeMapper.createNotice(noticeVO);
			return result;
		} else {
			log.info("NoFile noticeVO -> " + noticeVO);
			result = this.noticeMapper.createNoticeNoFile(noticeVO); // 파일이 없는 경우 호출
			return result;
		}
	}

	
	
	// 연/월/일 폴더 생성
		public String getFolder() {
			// 2024-01-30 형식(format) 지정
			// 간단한 날짜 형식
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
			// 날짜 객체 생성(java.util 패키지)
			Date date = new Date();
			// 2024-01-30
			String str = sdf.format(date);
			// 2024-01-30 -> 2024\\01\\30
			return str.replace("-", File.separator);
		}

		// 이미지인지 판단. 썸네일은 이미지만 가능하므로..
		public boolean checkImageType(File file) {
			// MIME(Multipurpose Internet Mail Extensions) : 문서, 파일 또는 바이트 집합의 성격과 형식. 표준화
			// MIME 타입 알아냄. .jpeg / .jpg의 MIME(ContentType)타입 : image/jpeg
			String contentType;
			try {
				contentType = Files.probeContentType(file.toPath());
				log.info("contentType : " + contentType);
				// image/jpeg는 image로 시작함->true
				return contentType.startsWith("image");
			} catch (IOException e) {
				e.printStackTrace();
			}
			// 이 파일이 이미지가 아닐 경우
			return false;
		}

		@Override
		public NoticeBoardVO detail(String noticeBrdNo) {
			return this.noticeMapper.detail(noticeBrdNo);
		}
		
		//상세정보 파일 목록
		@Override
		public List<AttachedFileVO> noticeAtchList(String atchmnflNo) {
			return this.noticeMapper.noticeAtchList(atchmnflNo);
		}
	
	
}
